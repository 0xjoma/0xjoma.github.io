<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Creating a Vulnerability Assessment Tool (VAT) with Python: Part I | From Bytes to Blogs</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Creating a Vulnerability Assessment Tool (VAT) with Python: Part I" />
<meta name="author" content="Jomael Ortiz Perez (0xjoma)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Overview The development focused on creating a Python-based vulnerability assessment tool, specifically targeting XSS (Cross-Site Scripting) vulnerabilities. The tool is designed to be run from the command line and allows users to scan specified URLs for potential vulnerabilities. It features modular code for easy maintenance and scalability. Project Structure CLI Parsing (cli.py) Responsible for parsing command-line arguments. Arguments include the target URL, chosen plugin (defaulting to XSS), and an option to disable SSL verification. # cli.py - Command line interface for VAT import argparse def parse_arguments(): parser = argparse.ArgumentParser(description=&quot;Vulnerability Assessment Tool&quot;) parser.add_argument(&quot;url&quot;, help=&quot;Target URL to scan&quot;) parser.add_argument(&quot;--plugin&quot;, default=&quot;xss&quot;, choices=[&quot;xss&quot;], help=&quot;Vulnerability plugin to use. Default is XSS.&quot;) parser.add_argument(&quot;--no-verify&quot;, action=&quot;store_true&quot;, help=&quot;Disable SSL verification&quot;) return parser.parse_args() Request Handling (requests_handler.py) Manages HTTPS/S requests to the target URL Handles SSL verification and related errors, providing an option to proceed without SSL verification upon user confirmation. Detailed SSL error messages are logged to a file for troubleshooting while presenting simplified messages to the user. # requests_handler.py import requests from requests.exceptions import SSLError import logging # Basic configuration for logging logging.basicConfig(filename=&#39;error_log.txt&#39;, level=logging.ERROR, format=&#39;%(asctime)s:%(levelname)s:%(message)s&#39;) def make_request(url, payload=None, verify_ssl=True): try: if payload: response = requests.get(url, params=payload, verify=verify_ssl) else: response = requests.get(url, verify=verify_ssl) return response, True except SSLError as ssl_error: logging.error(f&quot;SSL Certificate Error encountered for {url}: {ssl_error}&quot;) print(&quot;SSL Certificate Error: The site&#39;s security certificate is not trusted.&quot;) choice = input(&quot;Proceed without SSL verification? (yes/no): &quot;).lower() if choice == &#39;yes&#39;: print(&quot;Proceeding without SSL verification...&quot;) try: if payload: response = requests.get(url, params=payload, verify=False) else: response = requests.get(url, verify=False) return response, True except requests.RequestException as e: print(&quot;Error: Failed to make the request without SSL verification.&quot;) return None, False else: return None, False except requests.RequestException as e: print(f&quot;Error: Failed to make the request. Details: {e}&quot;) return None, False XSS Plugin (xss.py in plugins directory) Contains the check_xss function that sends a payload to the target URL to test for reflected XSS vulnerabilities. Utilizes the make_request function from request_handler.py. # xss.py from ..requests_handler import make_request def check_xss(url, verify_ssl=True): # A basic payload payload = &quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot; response, request_made = make_request(url, {&quot;q&quot;: payload}, verify_ssl=verify_ssl) if response: return (payload in response.text, request_made) else: return False, request_made Main Script (vat.py) Integrates all components. Orchestrates the workflow based on user input from the CLI. Handles final output messages to the user based on the scan results and any encountered issues. # vat.py from src.vat.cli import parse_arguments from src.vat.requests_handler import make_request from src.vat.plugins.xss import check_xss def main(): # Parse CLI arguments args = parse_arguments() print(f&quot;Scanning {args.url} using the {args.plugin} plugin...&quot;) # Handle SSL verification based on CLI argument verify_ssl = not args.no_verify # Check for vulnerabilities based on the chosen plugin if args.plugin == &quot;xss&quot;: vulnerable, performed_check = check_xss(args.url, verify_ssl) if performed_check: if vulnerable: print(f&quot;{args.url} is vulnerable to XSS!&quot;) else: print(f&quot;{args.url} is not vulnerable to XSS.&quot;) else: # Error message is printed by the requests_handler module print(f&quot;Scanning of {args.url} was aborted due to SSL verification failure.&quot;) if __name__ == &quot;__main__&quot;: main() Key Features and Functionality SSL Verification The tool rigorously handles SSL certificate verification. In case of SSL errors, users are prompted to choose whether to proceed without SSL verification. Detailed SSL errors are logged to error_log.txt, keeping user interaction clean and non-technical. XSS Vulnerability Checking The tool checks for a basic form of reflected XSS. Sends a test payload and checks if it is reflected in the response from the target URL. User-Friendly Interface Despite the complexity of the operations, the tool maintains a user-friendly command-line interface. Clear and concise messages are provided to the user, avoiding technical jargon and redundancy. Modular and Scalable Design: Code is organized into distinct modules for specific functionalities, promoting maintainability and scalability. The structure allows for easy addition of new features or plugins in the future. Testing and Validation The tool has been tested with various scenarios, including: URLs with valid SSL certificates. URLs with SSL certificate issues (e.g., https://expired.badssl.com/). With and without the –no-verify flag to test SSL verification handling. In all scenarios, the tool behaved as expected, providing appropriate user prompts and logging detailed errors where necessary. Conclusion Throughout the development of this vulnerability assessment tool, I have gained significant insights and accomplished several key objectives. This project not only enhanced my technical skills in Python programming but also deepened my understanding of software design principles and security considerations in application development. Key Learnings and Accomplishments: Modular Programming: By structuring the project into separate modules like cli.py, requests_handler.py, and xss.py, I learned the importance of modular design. This approach not only made the code more organized and maintainable but also simplified debugging and testing processes. Handling User Interactions: Implementing a user-friendly command-line interface taught me how to balance technical functionality with user experience. Crafting clear and non-technical messages, especially when handling SSL verification, was crucial in making the tool accessible to users without deep technical backgrounds. Error Handling and Logging: Dealing with SSL errors and implementing logging mechanisms was a significant learning curve. I learned to effectively catch and log errors while keeping the user interface clean. This aspect of the project underscored the importance of robust error handling in building reliable software. Security Practices: Working on a tool focused on detecting XSS vulnerabilities offered practical insights into web security vulnerabilities. It heightened my awareness of the security aspects crucial in software development and the importance of proactive testing for vulnerabilities. Future Scalability and Enhancements Looking ahead, there are several avenues for enhancing and scaling this tool: Expanding Vulnerability Checks: The current focus is on XSS vulnerabilities. I plan to extend the tool’s capabilities to include other common vulnerabilities like SQL injection, CSRF, and more, turning it into a more comprehensive security assessment tool. Improved Logging and Reporting: Enhancing the logging system to include more detailed reports, potentially with an option to generate summary reports, would make the tool more useful for in-depth security analysis. User Interface Enhancements: Incorporating more interactive elements into the CLI, such as progress indicators and more detailed help messages, could further improve the user experience. Automated Testing and CI Integration: Implementing automated tests and integrating the tool into a continuous integration (CI) pipeline would ensure its reliability and effectiveness in real-world scenarios. Customization and Configurability: Adding options for users to customize payloads and scan parameters would make the tool more versatile and adaptable to different testing environments. Finally, this project has been an immensely enriching experience, combining practical software development with the intricacies of web security. The skills and knowledge gained lay a strong foundation for future projects, especially in the realms of cybersecurity and software development. I look forward to continuing to enhance the tool, adding new features, and applying these learnings to future endeavors." />
<meta property="og:description" content="Overview The development focused on creating a Python-based vulnerability assessment tool, specifically targeting XSS (Cross-Site Scripting) vulnerabilities. The tool is designed to be run from the command line and allows users to scan specified URLs for potential vulnerabilities. It features modular code for easy maintenance and scalability. Project Structure CLI Parsing (cli.py) Responsible for parsing command-line arguments. Arguments include the target URL, chosen plugin (defaulting to XSS), and an option to disable SSL verification. # cli.py - Command line interface for VAT import argparse def parse_arguments(): parser = argparse.ArgumentParser(description=&quot;Vulnerability Assessment Tool&quot;) parser.add_argument(&quot;url&quot;, help=&quot;Target URL to scan&quot;) parser.add_argument(&quot;--plugin&quot;, default=&quot;xss&quot;, choices=[&quot;xss&quot;], help=&quot;Vulnerability plugin to use. Default is XSS.&quot;) parser.add_argument(&quot;--no-verify&quot;, action=&quot;store_true&quot;, help=&quot;Disable SSL verification&quot;) return parser.parse_args() Request Handling (requests_handler.py) Manages HTTPS/S requests to the target URL Handles SSL verification and related errors, providing an option to proceed without SSL verification upon user confirmation. Detailed SSL error messages are logged to a file for troubleshooting while presenting simplified messages to the user. # requests_handler.py import requests from requests.exceptions import SSLError import logging # Basic configuration for logging logging.basicConfig(filename=&#39;error_log.txt&#39;, level=logging.ERROR, format=&#39;%(asctime)s:%(levelname)s:%(message)s&#39;) def make_request(url, payload=None, verify_ssl=True): try: if payload: response = requests.get(url, params=payload, verify=verify_ssl) else: response = requests.get(url, verify=verify_ssl) return response, True except SSLError as ssl_error: logging.error(f&quot;SSL Certificate Error encountered for {url}: {ssl_error}&quot;) print(&quot;SSL Certificate Error: The site&#39;s security certificate is not trusted.&quot;) choice = input(&quot;Proceed without SSL verification? (yes/no): &quot;).lower() if choice == &#39;yes&#39;: print(&quot;Proceeding without SSL verification...&quot;) try: if payload: response = requests.get(url, params=payload, verify=False) else: response = requests.get(url, verify=False) return response, True except requests.RequestException as e: print(&quot;Error: Failed to make the request without SSL verification.&quot;) return None, False else: return None, False except requests.RequestException as e: print(f&quot;Error: Failed to make the request. Details: {e}&quot;) return None, False XSS Plugin (xss.py in plugins directory) Contains the check_xss function that sends a payload to the target URL to test for reflected XSS vulnerabilities. Utilizes the make_request function from request_handler.py. # xss.py from ..requests_handler import make_request def check_xss(url, verify_ssl=True): # A basic payload payload = &quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot; response, request_made = make_request(url, {&quot;q&quot;: payload}, verify_ssl=verify_ssl) if response: return (payload in response.text, request_made) else: return False, request_made Main Script (vat.py) Integrates all components. Orchestrates the workflow based on user input from the CLI. Handles final output messages to the user based on the scan results and any encountered issues. # vat.py from src.vat.cli import parse_arguments from src.vat.requests_handler import make_request from src.vat.plugins.xss import check_xss def main(): # Parse CLI arguments args = parse_arguments() print(f&quot;Scanning {args.url} using the {args.plugin} plugin...&quot;) # Handle SSL verification based on CLI argument verify_ssl = not args.no_verify # Check for vulnerabilities based on the chosen plugin if args.plugin == &quot;xss&quot;: vulnerable, performed_check = check_xss(args.url, verify_ssl) if performed_check: if vulnerable: print(f&quot;{args.url} is vulnerable to XSS!&quot;) else: print(f&quot;{args.url} is not vulnerable to XSS.&quot;) else: # Error message is printed by the requests_handler module print(f&quot;Scanning of {args.url} was aborted due to SSL verification failure.&quot;) if __name__ == &quot;__main__&quot;: main() Key Features and Functionality SSL Verification The tool rigorously handles SSL certificate verification. In case of SSL errors, users are prompted to choose whether to proceed without SSL verification. Detailed SSL errors are logged to error_log.txt, keeping user interaction clean and non-technical. XSS Vulnerability Checking The tool checks for a basic form of reflected XSS. Sends a test payload and checks if it is reflected in the response from the target URL. User-Friendly Interface Despite the complexity of the operations, the tool maintains a user-friendly command-line interface. Clear and concise messages are provided to the user, avoiding technical jargon and redundancy. Modular and Scalable Design: Code is organized into distinct modules for specific functionalities, promoting maintainability and scalability. The structure allows for easy addition of new features or plugins in the future. Testing and Validation The tool has been tested with various scenarios, including: URLs with valid SSL certificates. URLs with SSL certificate issues (e.g., https://expired.badssl.com/). With and without the –no-verify flag to test SSL verification handling. In all scenarios, the tool behaved as expected, providing appropriate user prompts and logging detailed errors where necessary. Conclusion Throughout the development of this vulnerability assessment tool, I have gained significant insights and accomplished several key objectives. This project not only enhanced my technical skills in Python programming but also deepened my understanding of software design principles and security considerations in application development. Key Learnings and Accomplishments: Modular Programming: By structuring the project into separate modules like cli.py, requests_handler.py, and xss.py, I learned the importance of modular design. This approach not only made the code more organized and maintainable but also simplified debugging and testing processes. Handling User Interactions: Implementing a user-friendly command-line interface taught me how to balance technical functionality with user experience. Crafting clear and non-technical messages, especially when handling SSL verification, was crucial in making the tool accessible to users without deep technical backgrounds. Error Handling and Logging: Dealing with SSL errors and implementing logging mechanisms was a significant learning curve. I learned to effectively catch and log errors while keeping the user interface clean. This aspect of the project underscored the importance of robust error handling in building reliable software. Security Practices: Working on a tool focused on detecting XSS vulnerabilities offered practical insights into web security vulnerabilities. It heightened my awareness of the security aspects crucial in software development and the importance of proactive testing for vulnerabilities. Future Scalability and Enhancements Looking ahead, there are several avenues for enhancing and scaling this tool: Expanding Vulnerability Checks: The current focus is on XSS vulnerabilities. I plan to extend the tool’s capabilities to include other common vulnerabilities like SQL injection, CSRF, and more, turning it into a more comprehensive security assessment tool. Improved Logging and Reporting: Enhancing the logging system to include more detailed reports, potentially with an option to generate summary reports, would make the tool more useful for in-depth security analysis. User Interface Enhancements: Incorporating more interactive elements into the CLI, such as progress indicators and more detailed help messages, could further improve the user experience. Automated Testing and CI Integration: Implementing automated tests and integrating the tool into a continuous integration (CI) pipeline would ensure its reliability and effectiveness in real-world scenarios. Customization and Configurability: Adding options for users to customize payloads and scan parameters would make the tool more versatile and adaptable to different testing environments. Finally, this project has been an immensely enriching experience, combining practical software development with the intricacies of web security. The skills and knowledge gained lay a strong foundation for future projects, especially in the realms of cybersecurity and software development. I look forward to continuing to enhance the tool, adding new features, and applying these learnings to future endeavors." />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2023/11/16/creating-a-vulnerability-assessment-tool-part-1.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2023/11/16/creating-a-vulnerability-assessment-tool-part-1.html" />
<meta property="og:site_name" content="From Bytes to Blogs" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-16T00:00:00-10:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Creating a Vulnerability Assessment Tool (VAT) with Python: Part I" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jomael Ortiz Perez (0xjoma)"},"dateModified":"2023-11-16T00:00:00-10:00","datePublished":"2023-11-16T00:00:00-10:00","description":"Overview The development focused on creating a Python-based vulnerability assessment tool, specifically targeting XSS (Cross-Site Scripting) vulnerabilities. The tool is designed to be run from the command line and allows users to scan specified URLs for potential vulnerabilities. It features modular code for easy maintenance and scalability. Project Structure CLI Parsing (cli.py) Responsible for parsing command-line arguments. Arguments include the target URL, chosen plugin (defaulting to XSS), and an option to disable SSL verification. # cli.py - Command line interface for VAT import argparse def parse_arguments(): parser = argparse.ArgumentParser(description=&quot;Vulnerability Assessment Tool&quot;) parser.add_argument(&quot;url&quot;, help=&quot;Target URL to scan&quot;) parser.add_argument(&quot;--plugin&quot;, default=&quot;xss&quot;, choices=[&quot;xss&quot;], help=&quot;Vulnerability plugin to use. Default is XSS.&quot;) parser.add_argument(&quot;--no-verify&quot;, action=&quot;store_true&quot;, help=&quot;Disable SSL verification&quot;) return parser.parse_args() Request Handling (requests_handler.py) Manages HTTPS/S requests to the target URL Handles SSL verification and related errors, providing an option to proceed without SSL verification upon user confirmation. Detailed SSL error messages are logged to a file for troubleshooting while presenting simplified messages to the user. # requests_handler.py import requests from requests.exceptions import SSLError import logging # Basic configuration for logging logging.basicConfig(filename=&#39;error_log.txt&#39;, level=logging.ERROR, format=&#39;%(asctime)s:%(levelname)s:%(message)s&#39;) def make_request(url, payload=None, verify_ssl=True): try: if payload: response = requests.get(url, params=payload, verify=verify_ssl) else: response = requests.get(url, verify=verify_ssl) return response, True except SSLError as ssl_error: logging.error(f&quot;SSL Certificate Error encountered for {url}: {ssl_error}&quot;) print(&quot;SSL Certificate Error: The site&#39;s security certificate is not trusted.&quot;) choice = input(&quot;Proceed without SSL verification? (yes/no): &quot;).lower() if choice == &#39;yes&#39;: print(&quot;Proceeding without SSL verification...&quot;) try: if payload: response = requests.get(url, params=payload, verify=False) else: response = requests.get(url, verify=False) return response, True except requests.RequestException as e: print(&quot;Error: Failed to make the request without SSL verification.&quot;) return None, False else: return None, False except requests.RequestException as e: print(f&quot;Error: Failed to make the request. Details: {e}&quot;) return None, False XSS Plugin (xss.py in plugins directory) Contains the check_xss function that sends a payload to the target URL to test for reflected XSS vulnerabilities. Utilizes the make_request function from request_handler.py. # xss.py from ..requests_handler import make_request def check_xss(url, verify_ssl=True): # A basic payload payload = &quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot; response, request_made = make_request(url, {&quot;q&quot;: payload}, verify_ssl=verify_ssl) if response: return (payload in response.text, request_made) else: return False, request_made Main Script (vat.py) Integrates all components. Orchestrates the workflow based on user input from the CLI. Handles final output messages to the user based on the scan results and any encountered issues. # vat.py from src.vat.cli import parse_arguments from src.vat.requests_handler import make_request from src.vat.plugins.xss import check_xss def main(): # Parse CLI arguments args = parse_arguments() print(f&quot;Scanning {args.url} using the {args.plugin} plugin...&quot;) # Handle SSL verification based on CLI argument verify_ssl = not args.no_verify # Check for vulnerabilities based on the chosen plugin if args.plugin == &quot;xss&quot;: vulnerable, performed_check = check_xss(args.url, verify_ssl) if performed_check: if vulnerable: print(f&quot;{args.url} is vulnerable to XSS!&quot;) else: print(f&quot;{args.url} is not vulnerable to XSS.&quot;) else: # Error message is printed by the requests_handler module print(f&quot;Scanning of {args.url} was aborted due to SSL verification failure.&quot;) if __name__ == &quot;__main__&quot;: main() Key Features and Functionality SSL Verification The tool rigorously handles SSL certificate verification. In case of SSL errors, users are prompted to choose whether to proceed without SSL verification. Detailed SSL errors are logged to error_log.txt, keeping user interaction clean and non-technical. XSS Vulnerability Checking The tool checks for a basic form of reflected XSS. Sends a test payload and checks if it is reflected in the response from the target URL. User-Friendly Interface Despite the complexity of the operations, the tool maintains a user-friendly command-line interface. Clear and concise messages are provided to the user, avoiding technical jargon and redundancy. Modular and Scalable Design: Code is organized into distinct modules for specific functionalities, promoting maintainability and scalability. The structure allows for easy addition of new features or plugins in the future. Testing and Validation The tool has been tested with various scenarios, including: URLs with valid SSL certificates. URLs with SSL certificate issues (e.g., https://expired.badssl.com/). With and without the –no-verify flag to test SSL verification handling. In all scenarios, the tool behaved as expected, providing appropriate user prompts and logging detailed errors where necessary. Conclusion Throughout the development of this vulnerability assessment tool, I have gained significant insights and accomplished several key objectives. This project not only enhanced my technical skills in Python programming but also deepened my understanding of software design principles and security considerations in application development. Key Learnings and Accomplishments: Modular Programming: By structuring the project into separate modules like cli.py, requests_handler.py, and xss.py, I learned the importance of modular design. This approach not only made the code more organized and maintainable but also simplified debugging and testing processes. Handling User Interactions: Implementing a user-friendly command-line interface taught me how to balance technical functionality with user experience. Crafting clear and non-technical messages, especially when handling SSL verification, was crucial in making the tool accessible to users without deep technical backgrounds. Error Handling and Logging: Dealing with SSL errors and implementing logging mechanisms was a significant learning curve. I learned to effectively catch and log errors while keeping the user interface clean. This aspect of the project underscored the importance of robust error handling in building reliable software. Security Practices: Working on a tool focused on detecting XSS vulnerabilities offered practical insights into web security vulnerabilities. It heightened my awareness of the security aspects crucial in software development and the importance of proactive testing for vulnerabilities. Future Scalability and Enhancements Looking ahead, there are several avenues for enhancing and scaling this tool: Expanding Vulnerability Checks: The current focus is on XSS vulnerabilities. I plan to extend the tool’s capabilities to include other common vulnerabilities like SQL injection, CSRF, and more, turning it into a more comprehensive security assessment tool. Improved Logging and Reporting: Enhancing the logging system to include more detailed reports, potentially with an option to generate summary reports, would make the tool more useful for in-depth security analysis. User Interface Enhancements: Incorporating more interactive elements into the CLI, such as progress indicators and more detailed help messages, could further improve the user experience. Automated Testing and CI Integration: Implementing automated tests and integrating the tool into a continuous integration (CI) pipeline would ensure its reliability and effectiveness in real-world scenarios. Customization and Configurability: Adding options for users to customize payloads and scan parameters would make the tool more versatile and adaptable to different testing environments. Finally, this project has been an immensely enriching experience, combining practical software development with the intricacies of web security. The skills and knowledge gained lay a strong foundation for future projects, especially in the realms of cybersecurity and software development. I look forward to continuing to enhance the tool, adding new features, and applying these learnings to future endeavors.","headline":"Creating a Vulnerability Assessment Tool (VAT) with Python: Part I","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2023/11/16/creating-a-vulnerability-assessment-tool-part-1.html"},"url":"http://localhost:4000/jekyll/update/2023/11/16/creating-a-vulnerability-assessment-tool-part-1.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="From Bytes to Blogs" />
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">From Bytes to Blogs</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Creating a Vulnerability Assessment Tool (VAT) with Python: Part I</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-16T00:00:00-10:00" itemprop="datePublished">
        Nov 16, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="overview">Overview</h2>

<p>The development focused on creating a Python-based vulnerability assessment tool, specifically targeting XSS (Cross-Site Scripting) vulnerabilities. The tool is designed to be run from the command line and allows users to scan specified URLs for potential vulnerabilities. It features modular code for easy maintenance and scalability.</p>

<h2 id="project-structure">Project Structure</h2>

<p>CLI Parsing (<code class="language-plaintext highlighter-rouge">cli.py</code>)</p>
<ul>
  <li>Responsible for parsing command-line arguments.</li>
  <li>Arguments include the target URL, chosen plugin (defaulting to XSS), and an option to disable SSL verification.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># cli.py - Command line interface for VAT
</span>
<span class="kn">import</span> <span class="nn">argparse</span>

<span class="k">def</span> <span class="nf">parse_arguments</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s">"Vulnerability Assessment Tool"</span><span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"url"</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">"Target URL to scan"</span><span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"--plugin"</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">"xss"</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s">"xss"</span><span class="p">],</span> <span class="n">help</span><span class="o">=</span><span class="s">"Vulnerability plugin to use. Default is XSS."</span><span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"--no-verify"</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">"store_true"</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">"Disable SSL verification"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>
</code></pre></div></div>

<p>Request Handling (<code class="language-plaintext highlighter-rouge">requests_handler.py</code>)</p>
<ul>
  <li>Manages HTTPS/S requests to the target URL</li>
  <li>Handles SSL verification and related errors, providing an option to proceed without SSL verification upon user confirmation.</li>
  <li>Detailed SSL error messages are logged to a file for troubleshooting while presenting simplified messages to the user.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># requests_handler.py
</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">requests.exceptions</span> <span class="kn">import</span> <span class="n">SSLError</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="c1"># Basic configuration for logging
</span><span class="n">logging</span><span class="p">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">'error_log.txt'</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="p">.</span><span class="n">ERROR</span><span class="p">,</span>
                    <span class="nb">format</span><span class="o">=</span><span class="s">'%(asctime)s:%(levelname)s:%(message)s'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">make_request</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verify_ssl</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">payload</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">payload</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="n">verify_ssl</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="n">verify_ssl</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">response</span><span class="p">,</span> <span class="bp">True</span>
    <span class="k">except</span> <span class="n">SSLError</span> <span class="k">as</span> <span class="n">ssl_error</span><span class="p">:</span>
        <span class="n">logging</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s">"SSL Certificate Error encountered for </span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">ssl_error</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"SSL Certificate Error: The site's security certificate is not trusted."</span><span class="p">)</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Proceed without SSL verification? (yes/no): "</span><span class="p">).</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="s">'yes'</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Proceeding without SSL verification..."</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">payload</span><span class="p">:</span>
                    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">payload</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">response</span><span class="p">,</span> <span class="bp">True</span>
            <span class="k">except</span> <span class="n">requests</span><span class="p">.</span><span class="n">RequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"Error: Failed to make the request without SSL verification."</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">False</span>
    <span class="k">except</span> <span class="n">requests</span><span class="p">.</span><span class="n">RequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Error: Failed to make the request. Details: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">False</span>
</code></pre></div></div>

<p>XSS Plugin (<code class="language-plaintext highlighter-rouge">xss.py</code> in <code class="language-plaintext highlighter-rouge">plugins</code> directory)</p>
<ul>
  <li>Contains the <code class="language-plaintext highlighter-rouge">check_xss</code> function that sends a payload to the target URL to test for reflected XSS vulnerabilities.</li>
  <li>Utilizes the <code class="language-plaintext highlighter-rouge">make_request</code> function from <code class="language-plaintext highlighter-rouge">request_handler.py</code>.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># xss.py
</span>
<span class="kn">from</span> <span class="nn">..requests_handler</span> <span class="kn">import</span> <span class="n">make_request</span>


<span class="k">def</span> <span class="nf">check_xss</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">verify_ssl</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="c1"># A basic payload
</span>    <span class="n">payload</span> <span class="o">=</span> <span class="s">"&lt;script&gt;alert('xss')&lt;/script&gt;"</span>
    <span class="n">response</span><span class="p">,</span> <span class="n">request_made</span> <span class="o">=</span> <span class="n">make_request</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="p">{</span><span class="s">"q"</span><span class="p">:</span> <span class="n">payload</span><span class="p">},</span> <span class="n">verify_ssl</span><span class="o">=</span><span class="n">verify_ssl</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">response</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">payload</span> <span class="ow">in</span> <span class="n">response</span><span class="p">.</span><span class="n">text</span><span class="p">,</span> <span class="n">request_made</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="n">request_made</span>
</code></pre></div></div>

<p>Main Script (<code class="language-plaintext highlighter-rouge">vat.py</code>)</p>
<ul>
  <li>Integrates all components.</li>
  <li>Orchestrates the workflow based on user input from the CLI.</li>
  <li>Handles final output messages to the user based on the scan results and any encountered issues.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># vat.py
</span>
<span class="kn">from</span> <span class="nn">src.vat.cli</span> <span class="kn">import</span> <span class="n">parse_arguments</span>
<span class="kn">from</span> <span class="nn">src.vat.requests_handler</span> <span class="kn">import</span> <span class="n">make_request</span>
<span class="kn">from</span> <span class="nn">src.vat.plugins.xss</span> <span class="kn">import</span> <span class="n">check_xss</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Parse CLI arguments
</span>    <span class="n">args</span> <span class="o">=</span> <span class="n">parse_arguments</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Scanning </span><span class="si">{</span><span class="n">args</span><span class="p">.</span><span class="n">url</span><span class="si">}</span><span class="s"> using the </span><span class="si">{</span><span class="n">args</span><span class="p">.</span><span class="n">plugin</span><span class="si">}</span><span class="s"> plugin..."</span><span class="p">)</span>

    <span class="c1"># Handle SSL verification based on CLI argument
</span>    <span class="n">verify_ssl</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">args</span><span class="p">.</span><span class="n">no_verify</span>

    <span class="c1"># Check for vulnerabilities based on the chosen plugin
</span>    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">plugin</span> <span class="o">==</span> <span class="s">"xss"</span><span class="p">:</span>
        <span class="n">vulnerable</span><span class="p">,</span> <span class="n">performed_check</span> <span class="o">=</span> <span class="n">check_xss</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">url</span><span class="p">,</span> <span class="n">verify_ssl</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">performed_check</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">vulnerable</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">args</span><span class="p">.</span><span class="n">url</span><span class="si">}</span><span class="s"> is vulnerable to XSS!"</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">args</span><span class="p">.</span><span class="n">url</span><span class="si">}</span><span class="s"> is not vulnerable to XSS."</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Error message is printed by the requests_handler module
</span>            <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Scanning of </span><span class="si">{</span><span class="n">args</span><span class="p">.</span><span class="n">url</span><span class="si">}</span><span class="s"> was aborted due to SSL verification failure."</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="key-features-and-functionality">Key Features and Functionality</h2>

<ol>
  <li>SSL Verification
    <ul>
      <li>The tool rigorously handles SSL certificate verification.</li>
      <li>In case of SSL errors, users are prompted to choose whether to proceed without SSL verification.</li>
      <li>Detailed SSL errors are logged to error_log.txt, keeping user interaction clean and non-technical.</li>
    </ul>
  </li>
  <li>XSS Vulnerability Checking
    <ul>
      <li>The tool checks for a basic form of reflected XSS.</li>
      <li>Sends a test payload and checks if it is reflected in the response from the target URL.</li>
    </ul>
  </li>
  <li>User-Friendly Interface
    <ul>
      <li>Despite the complexity of the operations, the tool maintains a user-friendly command-line interface.</li>
      <li>Clear and concise messages are provided to the user, avoiding technical jargon and redundancy.</li>
    </ul>
  </li>
  <li>Modular and Scalable Design:
    <ul>
      <li>Code is organized into distinct modules for specific functionalities, promoting maintainability and scalability.</li>
      <li>The structure allows for easy addition of new features or plugins in the future.</li>
    </ul>
  </li>
</ol>

<h2 id="testing-and-validation">Testing and Validation</h2>

<p>The tool has been tested with various scenarios, including:</p>
<ul>
  <li>URLs with valid SSL certificates.</li>
  <li>URLs with SSL certificate issues (e.g., https://expired.badssl.com/).</li>
  <li>With and without the –no-verify flag to test SSL verification handling.</li>
</ul>

<p>In all scenarios, the tool behaved as expected, providing appropriate user prompts and logging detailed errors where necessary.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Throughout the development of this vulnerability assessment tool, I have gained significant insights and accomplished several key objectives. This project not only enhanced my technical skills in Python programming but also deepened my understanding of software design principles and security considerations in application development.</p>

<h2 id="key-learnings-and-accomplishments">Key Learnings and Accomplishments:</h2>

<ol>
  <li>
    <p><strong>Modular Programming:</strong> By structuring the project into separate modules like cli.py, requests_handler.py, and xss.py, I learned the importance of modular design. This approach not only made the code more organized and maintainable but also simplified debugging and testing processes.</p>
  </li>
  <li>
    <p><strong>Handling User Interactions:</strong> Implementing a user-friendly command-line interface taught me how to balance technical functionality with user experience. Crafting clear and non-technical messages, especially when handling SSL verification, was crucial in making the tool accessible to users without deep technical backgrounds.</p>
  </li>
  <li>
    <p><strong>Error Handling and Logging:</strong> Dealing with SSL errors and implementing logging mechanisms was a significant learning curve. I learned to effectively catch and log errors while keeping the user interface clean. This aspect of the project underscored the importance of robust error handling in building reliable software.</p>
  </li>
  <li>
    <p><strong>Security Practices:</strong> Working on a tool focused on detecting XSS vulnerabilities offered practical insights into web security vulnerabilities. It heightened my awareness of the security aspects crucial in software development and the importance of proactive testing for vulnerabilities.</p>
  </li>
</ol>

<h2 id="future-scalability-and-enhancements">Future Scalability and Enhancements</h2>

<p>Looking ahead, there are several avenues for enhancing and scaling this tool:</p>

<ol>
  <li>
    <p><strong>Expanding Vulnerability Checks:</strong>  The current focus is on XSS vulnerabilities. I plan to extend the tool’s capabilities to include other common vulnerabilities like SQL injection, CSRF, and more, turning it into a more comprehensive security assessment tool.</p>
  </li>
  <li>
    <p><strong>Improved Logging and Reporting:</strong>  Enhancing the logging system to include more detailed reports, potentially with an option to generate summary reports, would make the tool more useful for in-depth security analysis.</p>
  </li>
  <li>
    <p><strong>User Interface Enhancements:</strong>  Incorporating more interactive elements into the CLI, such as progress indicators and more detailed help messages, could further improve the user experience.</p>
  </li>
  <li>
    <p><strong>Automated Testing and CI Integration:</strong>  Implementing automated tests and integrating the tool into a continuous integration (CI) pipeline would ensure its reliability and effectiveness in real-world scenarios.</p>
  </li>
  <li>
    <p><strong>Customization and Configurability:</strong>  Adding options for users to customize payloads and scan parameters would make the tool more versatile and adaptable to different testing environments.</p>
  </li>
</ol>

<p>Finally, this project has been an immensely enriching experience, combining practical software development with the intricacies of web security. The skills and knowledge gained lay a strong foundation for future projects, especially in the realms of cybersecurity and software development. I look forward to continuing to enhance the tool, adding new features, and applying these learnings to future endeavors.</p>


  </div><a class="u-url" href="/jekyll/update/2023/11/16/creating-a-vulnerability-assessment-tool-part-1.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/"></data>
  
    <div class="wrapper">
  
      <div class="footer-col-wrapper">
        <div class="footer-col">
          <p class="feed-subscribe">
            <a href="http://localhost:4000/feed.xml">
              <svg class="svg-icon orange">
                <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
              </svg><span>Subscribe</span>
            </a>
          </p>
          <ul class="contact-list">
            <li class="p-name">Jomael Ortiz Perez (0xjoma)</li>
            <li><a class="u-email" href="mailto:jomael.ortizperez.cv@proton.me">jomael.ortizperez.cv@proton.me</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <p>Aspiring cybersecurity expert and student delving deep into the world of digital defense. Discover my academic projects, insights from my learning journey, and my passion for ensuring a safer online experience.
</p>
        </div>
      </div>
  
      <div class="social-links"><ul class="social-media-list"><li>
  <a rel="me" href="https://github.com/0xjoma" target="_blank" title="github">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#github"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://x.com/0xjoma" target="_blank" title="twitter">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#twitter"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://www.linkedin.com/in/jomael-ortiz-perez-1384ba27b/" target="_blank" title="linkedin">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
    </svg>
  </a>
</li>
</ul></div>
  
    </div>
  
  </footer></body>

</html>
